from fastapi import FastAPI, HTTPException
from fastapi.responses import HTMLResponse
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import json
import pandas as pd
import plotly.graph_objects as go
import plotly.io as pio
from sqlalchemy import create_engine, text
from report_generator import ReportGenerator
import os
from dotenv import load_dotenv

load_dotenv()

app = FastAPI(title="API to Report Service", version="1.0.0")

class ReportRequest(BaseModel):
    original_query: str
    reformulated_query: Optional[str] = None
    sql_query: str
    # Optional: if plots are pre-generated by visualization agent
    plots: Optional[List[Dict[str, Any]]] = None

class ReportResponse(BaseModel):
    html_report: str
    success: bool
    message: str

def execute_sql_query(sql_query: str) -> pd.DataFrame:
    """Execute SQL query against PostgreSQL database"""
    try:
        postgres_uri = os.getenv("POSTGRES_URI")
        if not postgres_uri:
            raise ValueError("POSTGRES_URI not found in environment variables")
        
        engine = create_engine(postgres_uri)
        df = pd.read_sql_query(text(sql_query), engine)
        return df
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database query failed: {str(e)}")

def create_basic_plots(df: pd.DataFrame) -> List[go.Figure]:
    """Create basic visualizations from DataFrame if no plots provided"""
    plots = []
    
    # Get numeric and date columns
    numeric_cols = df.select_dtypes(include=['number']).columns.tolist()
    date_cols = df.select_dtypes(include=['datetime64']).columns.tolist()
    
    if len(numeric_cols) >= 1:
        # Plot 1: First numeric column over time/index
        fig1 = go.Figure()
        if date_cols:
            x_data = df[date_cols[0]]
            x_title = date_cols[0]
        else:
            x_data = df.index
            x_title = "Index"
            
        fig1.add_trace(go.Scatter(
            x=x_data,
            y=df[numeric_cols[0]],
            mode='lines+markers',
            name=numeric_cols[0]
        ))
        fig1.update_layout(
            title=f'{numeric_cols[0]} over {x_title}',
            xaxis_title=x_title,
            yaxis_title=numeric_cols[0],
            template='plotly_white'
        )
        plots.append(fig1)
    
    if len(numeric_cols) >= 2:
        # Plot 2: Distribution/comparison of numeric columns
        fig2 = go.Figure()
        fig2.add_trace(go.Bar(
            x=df.columns[:min(10, len(df.columns))],  # Limit to first 10 columns
            y=[df[col].sum() if col in numeric_cols else 0 for col in df.columns[:min(10, len(df.columns))]],
            name='Sum by Column'
        ))
        fig2.update_layout(
            title='Data Summary by Column',
            xaxis_title='Columns',
            yaxis_title='Sum',
            template='plotly_white'
        )
        plots.append(fig2)
    
    return plots

def reconstruct_plotly_figures(plots_data: List[Dict[str, Any]]) -> List[go.Figure]:
    """Convert plot JSON data back to Plotly Figure objects"""
    figures = []
    for i, plot_data in enumerate(plots_data):
        try:
            # Try different methods to reconstruct the figure
            if isinstance(plot_data, dict):
                fig = go.Figure(plot_data)
            else:
                fig = pio.from_json(json.dumps(plot_data))
            figures.append(fig)
        except Exception as e:
            # Create a simple placeholder figure if reconstruction fails
            fig = go.Figure()
            fig.add_annotation(
                text=f"Plot {i+1} reconstruction failed: {str(e)}", 
                xref="paper", yref="paper", x=0.5, y=0.5,
                showarrow=False
            )
            fig.update_layout(title=f"Plot {i+1} - Error")
            figures.append(fig)
    return figures

@app.post("/generate-report", response_model=ReportResponse)
async def generate_report(request: ReportRequest):
    """Generate a comprehensive report from SQL query and optional plots."""
    try:
        # Get OpenAI API key
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise HTTPException(status_code=500, detail="OpenAI API key not configured")
        
        # Initialize report generator
        report_generator = ReportGenerator(api_key)
        
        # Execute SQL query to get data
        df = execute_sql_query(request.sql_query)
        
        if df.empty:
            raise HTTPException(status_code=400, detail="SQL query returned no data")
        
        # Handle plots
        if request.plots:
            # Use provided plots
            plots = reconstruct_plotly_figures(request.plots)
        else:
            # Generate basic plots from data
            plots = create_basic_plots(df)
        
        # Use reformulated query if available, otherwise original
        query_for_analysis = request.reformulated_query or request.original_query
        
        # Generate the report
        report_content, plots = report_generator.generate_report(
            original_query=query_for_analysis,
            sql_results=df,
            plots=plots
        )
        
        # Convert to HTML
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.html', delete=False) as tmp:
            report_generator.save_report(report_content, plots, tmp.name)
            
            # Read the generated HTML file
            with open(tmp.name, 'r', encoding='utf-8') as f:
                html_content = f.read()
            
            # Clean up the temporary file
            os.unlink(tmp.name)
        
        return ReportResponse(
            html_report=html_content,
            success=True,
            message=f"Report generated successfully from {len(df)} rows of data"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating report: {str(e)}")

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy", 
        "service": "api-to-report",
        "database_configured": bool(os.getenv("POSTGRES_URI")),
        "openai_configured": bool(os.getenv("OPENAI_API_KEY"))
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)